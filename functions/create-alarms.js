const _ = require('lodash')
const AWS = require('aws-sdk')
const apigateway = new AWS.APIGateway()
const cloudwatch = new AWS.CloudWatch()
const log = require('../lib/log')

const alarmActions = (process.env.alarm_actions || '').split(',')
const okAction = (process.env.ok_actions || '').split(',')

async function enableDetailedMetrics(restApiId, stageName) {
  let getResp = await apigateway.getStage({ restApiId, stageName }).promise()
  log.debug('get stage settings', getResp.methodSettings)

  let isDetailedMetricsEnabled = _.get(getResp, 'methodSettings.*/*.metricsEnabled', false)
  if (isDetailedMetricsEnabled) {
    log.debug('detailed metrics already enabled', { restApiId, stageName })
  } else {
    let updateReq = {
      restApiId,
      stageName,
      patchOperations: [
        {
          path: '/*/*/metrics/enabled',
          value: 'true',
          op: 'replace'
        }
      ]
    }
    await apigateway.updateStage(updateReq).promise()
    log.debug('enabled detailed metrics', { restApiId, stageName })
  }
}

async function getRestEndpoints(restApiId) {
  let resp = await apigateway.getResources({ restApiId }).promise()
  log.debug('got REST resources', { restApiId })

  let resourceMethods = resp.items.map(x => {
    let methods = _.keys(x.resourceMethods)
    return methods.map(method => ({ resource: x.path, method }))
  })

  return _.flattenDeep(resourceMethods)
}

async function getRestApiName(restApiId) {
  let resp = await apigateway.getRestApi({ restApiId }).promise()
  log.debug('got REST api', { restApiId })

  return resp.name
}

async function createAlarmsForEndpoints(restApiId, stageName) {
  let apiName = await getRestApiName(restApiId)
  log.debug(`API name is ${apiName}`, { restApiId, stageName })

  let restEndpoints = await getRestEndpoints(restApiId)
  log.debug('got REST endpoints', { restApiId, stageName, restEndpoints })

  for (let endpoint of restEndpoints) {
    let putReq = {
      AlarmName: `API [${apiName}] stage [${stageName}] ${endpoint.method} ${endpoint.resource} : p99 > 1s`,
      MetricName: 'Latency',
      Dimensions: [
        { Name: 'ApiName', Value: apiName },
        { Name: 'Resource', Value: endpoint.resource },
        { Name: 'Method', Value: endpoint.method },
        { Name: 'Stage', Value: stageName }
      ],
      Namespace: 'AWS/ApiGateway',
      Threshold: 1000, // 1s
      ComparisonOperator: 'GreaterThanThreshold',
      Period: 60, // per min
      EvaluationPeriods: 5,
      DatapointsToAlarm: 5, // 5 consecutive mins to trigger alarm
      ExtendedStatistic: 'p99',
      ActionsEnabled: true,
      AlarmActions: alarmActions,
      AlarmDescription: `auto-generated by Lambda [${process.env.AWS_LAMBDA_FUNCTION_NAME}]`,
      OKActions: okAction,
      Unit: 'Milliseconds'
    }
    await cloudwatch.putMetricAlarm(putReq).promise()
  }

  log.debug('auto-created latency ALARMS for REST endpoints', { restApiId, stageName, restEndpoints })
}

module.exports.handler = async (event, context, cb) => {
  let restApiId = event.detail.requestParameters.restApiId
  let stageName = event.detail.requestParameters.createDeploymentInput.stageName

  await enableDetailedMetrics(restApiId, stageName)

  await createAlarmsForEndpoints(restApiId, stageName)

  return 'ok'
}
